# -*- coding: utf-8 -*-
"""pose estimation function.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SNx4ZF6qJ2YVq9PAhDOZUhjuSFwbo56d
"""

# !pip install mediapipe

from google.colab.patches import cv2_imshow
import mediapipe as mp
import cv2

# Initialize MediaPipe Pose model
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(static_image_mode=False, model_complexity=2)

def pose_estimation(image_path):
  image = cv2.imread(image_path)
  image = cv2.resize(image, (1280, 1280)) #resizing image

  # Convert the image to RGB as MediaPipe works with RGB images
  image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

  # Perform initial pose detection
  results = pose.process(image_rgb)


  #for i in range(0,results.pose_landmarks):
    #print(results.pose_landmarks[i].name)
  keypoints={}
  # Check if any landmarks were detected
  if results.pose_landmarks:

          mp.solutions.drawing_utils.draw_landmarks(
              image, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

          for i,landmark in enumerate(results.pose_landmarks.landmark):  #  we had to use enumerate as it is a landmarknormalized class and is not subscriptable at all , that's why a seperate dictionary is also created to store the bodypart
            bodypart={
                'x':landmark.x,  # please note x, y, z are ratios normalized between [0,1] which when multiplied by the image resolution provide the actual coordinates of the keypoint
                'y':landmark.y,
                'z':landmark.z,
                'visibility':landmark.visibility,
            }
            keypoints[mp_pose.PoseLandmark(i).name]=bodypart

          # Display the cropped image with landmarks
          print(image[0][0])
          cv2_imshow(image)
          cv2.waitKey(0)

  return keypoints
# Release the resources

print(pose_estimation('/content/KritiSanon-Filmfare_1080x.jpeg'))